[
  
  {
    "title": "NPS流量监控功能源码阅读",
    "url": "/posts/NPS%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/",
    "categories": "工具, NPS",
    "tags": "NPS, 学习笔记, 源码",
    "date": "2025-10-24 09:20:46 +0800",
    "content": "一，数据结构设计  type Flow struct { \tExportFlow int64  //出口流量 \tInletFlow  int64  //入口流量 \tFlowLimit  int64  //流量限制 \tsync.RWMutex      //读写锁保证并发安全 }  这个结构体会被嵌入Client、Tunnel、Host对象中，用于分别统计客户端、隧道和主机的流量     读写锁sync.RWMutex        读操作可并行，不会有安全隐患     写操作不可并行，多个写操作同时进行可能同时从内存取出同样的值，自增并写入新值，发生数据竞争的问题      二，流量监控核心机制 连接级别的流量统计 //位于lib/goroutine/pool.go func copyConns(group interface{}) {     conns := group.(Conns)     wg := new(sync.WaitGroup)     wg.Add(2)     var in, out int64          //使用协程池处理两个方向的流量     _ = connCopyPool.Invoke(newConnGroup(conns.conn1, conns.conn2, wg, &amp;in))     _ = connCopyPool.Invoke(newConnGroup(conns.conn2, conns.conn1, wg, &amp;out))          wg.Wait()          //将统计的流量数据添加到Flow对象     if conns.flow != nil {         conns.flow.Add(in, out)     }     conns.wg.Done() }  服务端服务器统计从用户转发到客户端端以及从客户端返回到用户的上行和下行流量并记录    goroutine和协程池(goroutine pool): goroutine由go func()启动，任务结束了就无法复用，协程池是有固定的goroutine数量长期运行，不断从任务队列获取任务并执行，这里使用协程池是保证内存占用可控   流量累加机制 //lib/file/obj.go func (s *Flow) Add(in, out int64) {     s.Lock()     defer s.Unlock()     s.InletFlow += int64(in)   //累加上行流量     s.ExportFlow += int64(out) //累加下行流量 }     defer可以让锁在函数返回时解开，可以保证panic的时候也能正常释放锁   三，服务端流量聚合  定时聚合任务 //server/server.go func dealClientFlow() {     ticker := time.NewTicker(time.Minute) //每分钟执行一次     defer ticker.Stop()     for {         select {         case &lt;-ticker.C:             dealClientData() //处理客户端数据         }     } }     使用select是因为没有default可以阻塞等待，不会空转cpu   客户端流量汇总  func dealClientData() {     file.GetDb().JsonDb.Clients.Range(func(key, value interface{}) bool {         v := value.(*file.Client)         v.Flow.InletFlow = 0         v.Flow.ExportFlow = 0                  // 汇总该客户端下所有Host的流量         file.GetDb().JsonDb.Hosts.Range(func(key, value interface{}) bool {             h := value.(*file.Host)             if h.Client.Id == v.Id {                 v.Flow.InletFlow += h.Flow.InletFlow                 v.Flow.ExportFlow += h.Flow.ExportFlow             }             return true         })                  // 汇总该客户端下所有Tunnel的流量         file.GetDb().JsonDb.Tasks.Range(func(key, value interface{}) bool {             t := value.(*file.Tunnel)             if t.Client.Id == v.Id {                 v.Flow.InletFlow += t.Flow.InletFlow                 v.Flow.ExportFlow += t.Flow.ExportFlow             }             return true         })         return true     }) }  四，流量限制和速度控制  流量限制检查 //server/proxy/base.go func (s *BaseServer) CheckFlowAndConnNum(client *file.Client) error {     // 检查流量是否超限     if client.Flow.FlowLimit &gt; 0 &amp;&amp;         (client.Flow.FlowLimit&lt;&lt;20) &lt; (client.Flow.ExportFlow+client.Flow.InletFlow) {         return errors.New(\"Traffic exceeded\")     }     // 检查连接数是否超限     if !client.GetConn() {         return errors.New(\"Connections exceed the current client limit\")     }     return nil }  "
  },
  
  {
    "title": "React 18源码学习笔记",
    "url": "/posts/React-18%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
    "categories": "前端, React",
    "tags": "React, 学习笔记, 源码",
    "date": "2025-10-14 01:40:46 +0800",
    "content": "第一章 基础概念 一.虚拟DOM 1.什么是虚拟DOM 虚拟DOM是js对象，是对真实DOM的抽象表示：  const virtualDOM = { \ttype: \"div\", \tprops: { \t\tclassName: \"container\", \t\tchildiren: [ \t\t\t{ \t\t\t\ttype: \"h1\", \t\t\t\tprops: { \t\t\t\t\tchildren: \"Hello World\", \t\t\t\t}, \t\t\t}, \t\t], \t};  可以体现出react的设计哲学 2.虚拟DOM工作流程    状态变化   生成新的虚拟DOM   Diff比较   计算最小更新   批量更新真实DOM     二.JSX     1.什么是JSX     jsx是js的语法扩展，允许在js中写HTML样的代码     2.JSX的编译（Babel转换）     ```js // jsx代码 const element = &lt;div className = \"greeting\"&gt;Hello,{name}!&lt;/div&gt;;      //编译成JS的代码 const element = React.createElement( \t“div”, \t{ className: “greeting” }, \t“Hello, “, \tname, \t“!” ); ceateElemen下的第一行（type），第二行（props），第三行及以下（其他子节点children） ## 三.React Element ### 1.React Element的结构 ```js const element = { \t// 元素类型 \ttype: \"string\" | type of ReactComponent,  \t// 元素属性 \tprops: { \t\t// 标准dom属性 \t\tclassName: \"container\", \t\tstyle: { color: \"red\" },  \t\t// React 特殊属性 \t\tkey: \"unique-key\", \t\tref: refObjiect,  \t\t//子元素 \t\tchildren: [ \t\t\t\"文本内容\", \t\t\tReactElement, \t\t\t[ReactElement],//数组 \t\t\tnull, \t\t\tfalse, \t\t], \t},  \t// 内部属性 \t_owner: Fiber, \t_store: {}, \t_self: null, \t_source: null, };  2.Element类型 原生DOM元素 { \ttype: 'div', \tprops: { className: 'container' } }   函数组件 { \ttype: function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; }, \tprops: { name: 'React' } }   类组件 { \ttype: class Welcome extends React.Component { ... }, \tprops: { name: 'React' } }  Fragment { \ttype: Symbol(react.fragment), \tprops: { children: [element1, element2] } }  3.创建React Element // 使用React.createELement const element = React.createElement( \t\"div\", \t{ className: \"greeting\" }, \t\"Hello,World!\" );  // 使用JSX const element = &lt;div className = \"greeting\"&gt;Hello,World!&lt;/div&gt;;  // 使用 React.cloneElement克隆元素 const clonedElement = React.cloneElement(element, { \tclassName: \"greeting-cloned\", });  三.源码学习重点 1.核心文件     packages/react/src/ReactElement.js - React元素创建   packages/react/src/React.js - React核心API   packages/react/src/jsx/ReactJSXElement.js - JSX转换  ### 2.关键函数  ```js  // React.createElement 函数签名  export function createElement(type, config, children) {   // 处理 props   // 处理 children  \t // 创建 ReactElement  } // React.cloneElement 函数签名 export function cloneElement(element, config, children) {  // 克隆现有元素  // 合并新的 Props  //返回新元素 }   ``` 第二章 Fiber框架 一.简介Fiber 在React 16之前，React使用递归的方式处理组件树，会出现以下问题：    无法中断渲染   长时间计算阻塞用户交互（主线程）   所有更新状态都是同步的，无法确立优先级   Fiber的核心思想：将渲染工作分解为小的、可中断的工作单位  于是，FIber就引入了一种协作式调度机制：    把整个组件书的渲染过程拆成一个个小任务（每个Fibet节点就是一个任务单元）   每执行完一个任务，就检查是否还有时间继续   如果浏览器需要处理用户输入、动画等高优先级任务，React就会暂停当前工作，等空闲时再从断电恢复  "
  },
  
  {
    "title": "go语言学习笔记",
    "url": "/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
    "categories": "后端, go",
    "tags": "go, 学习笔记",
    "date": "2025-10-14 01:40:46 +0800",
    "content": "go语言学习笔记 一.go的优点 1.简化c++，简化开发流程 2.对于java的spring，go的gin启动速度更快 二.go的语法 导入与导出 导入 import { \t//目标文件的路径 }  导出 func名字的首字母为大写则可被其它文件调用，小写则只能被当前文件内调用 变量 定义 i := 2 var i = 2 var i int = 2  上述三种赋值方法是等价的 类型 // int int8 int16 int32 int64 整型 // uint uint8 uint32 uint64 uintptr（无符号整型指针） 无符号型 // float32 float64 complex64 complex128 浮点型 // bool string byte rune 其他  类型转换  i := float64(6)  数组  var a [2]string  a[0] = \"hello\"  循环与选择 for i := 0; i &lt; 10; i++ { \tsum += i }  for sum &lt; 100{ \tsum += sum }  if v := math.Pox(x, n); v &lt; i { \treturn 1 } // 可内部先运算再判断 // switch 也是一样，但switch可以无比较变量，这种情况类似与if else嵌套 // switch 的case可自动跳出不需要break  2.函数func func demo(x int,y string) (string int) { \treturn y,x }  前一个括号为传参类型后一个括号为返回值类型 若传参写为 (x, y string)  则等于 （x string, y string）  同时，若只有一个返回值，可以不用加括号 结构体与指针 type v struct { \tx int \ty int }  func Main() { \tv := v{1,2} \tp := &amp;v \tp.x = 3 //指针自动解引用 \tp,y = 4 \tfmt.Println(*p) //打印时不行 }  切片 arr := []int{0,1,2,3,4,5,6} s := arr[1:4] x := arr[4:] y := arr[:2]  // s == [1, 2, 3] 左闭右开 // x == [5, 6] 开区间 // y == [0, 1]  for i, v := range b{  fmt.Print(\"%d: %d | \", i, v) } // i是索引，b是值  for _, v := range b{  fmt.Print(\"%d | \", v) } // 不需要的值可以用_代替  "
  },
  
  {
    "title": "es6学习笔记",
    "url": "/posts/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
    "categories": "前端, js",
    "tags": "es6, 学习笔记",
    "date": "2025-01-18 20:54:12 +0800",
    "content": "es6语法笔记 1.变量let与常量const { \tlet count = 10 } console.log(count)//无法读取变量count  const a = 1 a = 0//此行代码无法执行  2.模板字符串 const str1 = 'abc' + \"def\" const str2 = `hij${str1} \t\t\t\t  这个字符串还能带换行效果 \t\t\t `  3.解构赋值 //数组解构 const [a,b,c] = [1,2,3] console.log(a)  //对象解构 const {username, age:userAge, ...otherInfo} = { \t\tusername = 'tianyu', \t\tage = 18, \t\tx = 1, \t\ty = 2, \t\tz = 3 \t} console.log(username,userAge,otherInfo)  4.数组和对象的扩展 4.1 扩展运算符 const arr1 = [1, 2, 3] const arr2 = [4, 5, 6] const arr3 = [...arr1, ...arr2, 3, 4]  const obj1 = { \ta = 1 } const obj2 = { \tb = 2 } const obj3 = { \tc = 3, \t...obj1, \t...obj2 }  这里的…（扩展运算符）和上边的…(解构中的意义不同) 4.2 数组方法Array.from() 使伪数组可以被正常使用 function fn () { \tArray.from(arguments).forEach(function (item) { \t\tconsole.log(item) \t}) fn(1, 2, 3, 4)  4.3 对象方法Object.assign() 合并or拷贝对象  const obj1 = { \tname = 'tianyu', \tage = 18 } const obj2 = { \tc = 1, \td= 2 } const obj2 = Object.assign({}, obj1, obj2)  5.Class 通过构造的方式快速生成对象 class A { \tconstructor (name, age ) { \t\tthis.name = name \t\tthis.age = age \t\t} \tintroduce （）{ \t\tconsole.log('我的名字是${this.name},我的年龄是${this.age}')\t \t}  const a1 = new A('tianyu', 18)//实例化 a1.introduce() //继承 class B extends A { \tconstructor (name, age, gender) { \t\tsuper(name, age) \t\tthis.gender = grnder \t} \tsayHello  () { \tconsole.log('你好我是'+this.name) \t} } const b1 =nwe B('tianyu', 18, '男') b1.sayHello() b1.constructor()  6.箭头函数 const getSum = (n1, n2) =&gt; { \treturn n1 + n2 } //可简写为以下样式 const getSum = (n1, n2) =&gt; n1 + n2  const getSum = (n1, n2, ...other) =&gt; console.log(n1, n2, other) //该...other为REST函数，用于接收多余的参数，与以上的两种\"...\"意义不同  "
  }
  
]

