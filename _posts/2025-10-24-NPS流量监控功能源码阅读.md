---
title: NPS流量监控功能源码阅读
date: 2025-10-24 09:20:46 +0800
categories: [工具, NPS]
tags: [NPS,学习笔记,源码]
---

# 一，数据结构设计

```go
type Flow struct {
	ExportFlow int64  //出口流量
	InletFlow  int64  //入口流量
	FlowLimit  int64  //流量限制
	sync.RWMutex      //读写锁保证并发安全
}
```
这个结构体会被嵌入Client、Tunnel、Host对象中，用于分别统计客户端、隧道和主机的流量

>读写锁sync.RWMutex
>- 读操作可并行，不会有安全隐患
>- 写操作不可并行，多个写操作同时进行可能同时从内存取出同样的值，自增并写入新值，发生数据竞争的问题

# 二，流量监控核心机制
## 连接级别的流量统计
```go
//位于lib/goroutine/pool.go
func copyConns(group interface{}) {
    conns := group.(Conns)
    wg := new(sync.WaitGroup)
    wg.Add(2)
    var in, out int64
    
    //使用协程池处理两个方向的流量
    _ = connCopyPool.Invoke(newConnGroup(conns.conn1, conns.conn2, wg, &in))
    _ = connCopyPool.Invoke(newConnGroup(conns.conn2, conns.conn1, wg, &out))
    
    wg.Wait()
    
    //将统计的流量数据添加到Flow对象
    if conns.flow != nil {
        conns.flow.Add(in, out)
    }
    conns.wg.Done()
}
```
服务端服务器统计从用户转发到客户端端以及从客户端返回到用户的上行和下行流量并记录
>**goroutine和协程池(goroutine pool):**
>goroutine由go func()启动，任务结束了就无法复用，协程池是有固定的goroutine数量长期运行，不断从任务队列获取任务并执行，这里使用协程池是保证内存占用可控

## 流量累加机制
```go
//lib/file/obj.go
func (s *Flow) Add(in, out int64) {
    s.Lock()
    defer s.Unlock()
    s.InletFlow += int64(in)   //累加上行流量
    s.ExportFlow += int64(out) //累加下行流量
}
```
>defer可以让锁在函数返回时解开，可以保证panic的时候也能正常释放锁

# 三，服务端流量聚合

## 定时聚合任务
```go
//server/server.go
func dealClientFlow() {
    ticker := time.NewTicker(time.Minute) //每分钟执行一次
    defer ticker.Stop()
    for {
        select {
        case <-ticker.C:
            dealClientData() //处理客户端数据
        }
    }
}
```
>使用select是因为没有default可以阻塞等待，不会空转cpu

## 客户端流量汇总

```go
func dealClientData() {
    file.GetDb().JsonDb.Clients.Range(func(key, value interface{}) bool {
        v := value.(*file.Client)
        v.Flow.InletFlow = 0
        v.Flow.ExportFlow = 0
        
        // 汇总该客户端下所有Host的流量
        file.GetDb().JsonDb.Hosts.Range(func(key, value interface{}) bool {
            h := value.(*file.Host)
            if h.Client.Id == v.Id {
                v.Flow.InletFlow += h.Flow.InletFlow
                v.Flow.ExportFlow += h.Flow.ExportFlow
            }
            return true
        })
        
        // 汇总该客户端下所有Tunnel的流量
        file.GetDb().JsonDb.Tasks.Range(func(key, value interface{}) bool {
            t := value.(*file.Tunnel)
            if t.Client.Id == v.Id {
                v.Flow.InletFlow += t.Flow.InletFlow
                v.Flow.ExportFlow += t.Flow.ExportFlow
            }
            return true
        })
        return true
    })
}
```
# 四，流量限制和速度控制

## 流量限制检查
```go
//server/proxy/base.go
func (s *BaseServer) CheckFlowAndConnNum(client *file.Client) error {
    // 检查流量是否超限
    if client.Flow.FlowLimit > 0 && 
       (client.Flow.FlowLimit<<20) < (client.Flow.ExportFlow+client.Flow.InletFlow) {
        return errors.New("Traffic exceeded")
    }
    // 检查连接数是否超限
    if !client.GetConn() {
        return errors.New("Connections exceed the current client limit")
    }
    return nil
}
```